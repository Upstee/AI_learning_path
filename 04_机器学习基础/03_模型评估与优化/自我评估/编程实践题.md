# 模型评估与优化 - 编程实践题

## 题目1：实现完整的分类评估系统（40分）

### 要求

实现一个完整的分类评估系统，包括以下功能：

1. **评估指标计算**（15分）
   - 准确率、精确率、召回率、F1分数
   - 混淆矩阵
   - ROC曲线和AUC值

2. **可视化功能**（10分）
   - 混淆矩阵热力图
   - ROC曲线图
   - 评估指标对比柱状图

3. **报告生成**（10分）
   - 生成包含所有指标的评估报告
   - 报告格式清晰，易于阅读

4. **代码质量**（5分）
   - 代码结构清晰
   - 注释完整
   - 遵循PEP 8规范

### 评分标准

- **功能实现正确**（30分）：所有功能正确实现
- **可视化清晰**（5分）：图表清晰、标签完整
- **报告完整**（3分）：报告包含所有必要信息
- **代码质量**（2分）：代码规范、注释完整

### 参考答案

```python
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import (accuracy_score, precision_score, recall_score, 
                            f1_score, confusion_matrix, roc_curve, auc)

class ClassificationEvaluator:
    """分类模型评估器"""
    
    def __init__(self, y_true, y_pred, y_pred_proba=None):
        """
        初始化评估器
        参数:
            y_true: 真实标签
            y_pred: 预测标签
            y_pred_proba: 预测概率（用于ROC曲线）
        """
        self.y_true = y_true
        self.y_pred = y_pred
        self.y_pred_proba = y_pred_proba
        self.results = {}
    
    def calculate_metrics(self):
        """计算所有评估指标"""
        self.results['accuracy'] = accuracy_score(self.y_true, self.y_pred)
        self.results['precision'] = precision_score(self.y_true, self.y_pred)
        self.results['recall'] = recall_score(self.y_true, self.y_pred)
        self.results['f1'] = f1_score(self.y_true, self.y_pred)
        self.results['confusion_matrix'] = confusion_matrix(self.y_true, self.y_pred)
        
        if self.y_pred_proba is not None:
            fpr, tpr, _ = roc_curve(self.y_true, self.y_pred_proba)
            self.results['roc_auc'] = auc(fpr, tpr)
            self.results['fpr'] = fpr
            self.results['tpr'] = tpr
        
        return self.results
    
    def visualize(self):
        """可视化评估结果"""
        fig, axes = plt.subplots(1, 3, figsize=(18, 5))
        
        # 混淆矩阵
        sns.heatmap(self.results['confusion_matrix'], annot=True, fmt='d', 
                   cmap='Blues', ax=axes[0])
        axes[0].set_title('混淆矩阵')
        
        # 评估指标对比
        metrics = ['准确率', '精确率', '召回率', 'F1分数']
        values = [self.results['accuracy'], self.results['precision'],
                 self.results['recall'], self.results['f1']]
        axes[1].bar(metrics, values, alpha=0.7)
        axes[1].set_title('评估指标对比')
        axes[1].set_ylim([0, 1])
        
        # ROC曲线
        if self.y_pred_proba is not None:
            axes[2].plot(self.results['fpr'], self.results['tpr'], 
                        label=f'ROC (AUC = {self.results["roc_auc"]:.2f})')
            axes[2].plot([0, 1], [0, 1], 'k--')
            axes[2].set_xlabel('假正例率')
            axes[2].set_ylabel('真正例率')
            axes[2].set_title('ROC曲线')
            axes[2].legend()
        
        plt.tight_layout()
        plt.show()
    
    def generate_report(self):
        """生成评估报告"""
        report = f"""
分类模型评估报告
{'='*50}
准确率: {self.results['accuracy']:.4f}
精确率: {self.results['precision']:.4f}
召回率: {self.results['recall']:.4f}
F1分数: {self.results['f1']:.4f}
"""
        if self.y_pred_proba is not None:
            report += f"ROC-AUC: {self.results['roc_auc']:.4f}\n"
        
        report += f"\n混淆矩阵:\n{self.results['confusion_matrix']}"
        return report

# 使用示例
# from sklearn.datasets import make_classification
# from sklearn.model_selection import train_test_split
# from sklearn.ensemble import RandomForestClassifier
# 
# X, y = make_classification(n_samples=1000, random_state=42)
# X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
# 
# model = RandomForestClassifier(random_state=42)
# model.fit(X_train, y_train)
# y_pred = model.predict(X_test)
# y_pred_proba = model.predict_proba(X_test)[:, 1]
# 
# evaluator = ClassificationEvaluator(y_test, y_pred, y_pred_proba)
# evaluator.calculate_metrics()
# evaluator.visualize()
# print(evaluator.generate_report())
```

---

## 题目2：实现交叉验证和超参数调优系统（35分）

### 要求

实现一个交叉验证和超参数调优系统，包括：

1. **K折交叉验证**（10分）
   - 实现K折交叉验证函数
   - 支持多种评估指标
   - 返回每折的得分和平均得分

2. **网格搜索**（10分）
   - 实现简单的网格搜索功能
   - 支持参数网格定义
   - 返回最佳参数和得分

3. **结果可视化**（10分）
   - 交叉验证得分分布图
   - 参数搜索过程可视化

4. **代码质量**（5分）
   - 代码结构清晰
   - 注释完整

### 评分标准

- **功能实现正确**（25分）：所有功能正确实现
- **可视化清晰**（5分）：图表清晰、信息完整
- **代码质量**（5分）：代码规范、注释完整

### 参考答案

```python
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import KFold
from itertools import product

def k_fold_cross_validation(model, X, y, k=5, scoring='accuracy'):
    """
    K折交叉验证
    参数:
        model: 模型对象
        X: 特征数据
        y: 目标数据
        k: 折数
        scoring: 评估指标
    返回:
        scores: 每折的得分列表
        mean_score: 平均得分
        std_score: 标准差
    """
    kf = KFold(n_splits=k, shuffle=True, random_state=42)
    scores = []
    
    for train_idx, val_idx in kf.split(X):
        X_train, X_val = X[train_idx], X[val_idx]
        y_train, y_val = y[train_idx], y[val_idx]
        
        model.fit(X_train, y_train)
        y_pred = model.predict(X_val)
        
        if scoring == 'accuracy':
            from sklearn.metrics import accuracy_score
            score = accuracy_score(y_val, y_pred)
        elif scoring == 'f1':
            from sklearn.metrics import f1_score
            score = f1_score(y_val, y_pred)
        else:
            raise ValueError(f"不支持的评估指标: {scoring}")
        
        scores.append(score)
    
    return scores, np.mean(scores), np.std(scores)

def grid_search(model_class, X, y, param_grid, cv=5):
    """
    网格搜索
    参数:
        model_class: 模型类
        X: 特征数据
        y: 目标数据
        param_grid: 参数网格字典
        cv: 交叉验证折数
    返回:
        best_params: 最佳参数
        best_score: 最佳得分
        results: 所有结果
    """
    param_names = list(param_grid.keys())
    param_values = list(param_grid.values())
    
    best_score = -np.inf
    best_params = None
    results = []
    
    for param_combo in product(*param_values):
        params = dict(zip(param_names, param_combo))
        model = model_class(**params)
        
        scores, mean_score, std_score = k_fold_cross_validation(
            model, X, y, k=cv, scoring='accuracy'
        )
        
        results.append({
            'params': params,
            'mean_score': mean_score,
            'std_score': std_score,
            'scores': scores
        })
        
        if mean_score > best_score:
            best_score = mean_score
            best_params = params
    
    return best_params, best_score, results

# 使用示例
# from sklearn.ensemble import RandomForestClassifier
# from sklearn.datasets import load_iris
# 
# iris = load_iris()
# X, y = iris.data, iris.target
# 
# param_grid = {
#     'n_estimators': [50, 100],
#     'max_depth': [3, 5, None]
# }
# 
# best_params, best_score, results = grid_search(
#     RandomForestClassifier, X, y, param_grid, cv=5
# )
# 
# print(f"最佳参数: {best_params}")
# print(f"最佳得分: {best_score:.4f}")
```

---

## 题目3：实现回归模型评估系统（25分）

### 要求

实现一个回归模型评估系统，包括：

1. **评估指标计算**（10分）
   - MSE、RMSE、MAE、R²

2. **残差分析**（10分）
   - 残差分布图
   - 残差 vs 预测值图

3. **代码质量**（5分）
   - 代码规范、注释完整

### 评分标准

- **功能实现正确**（15分）
- **可视化清晰**（5分）
- **代码质量**（5分）

### 参考答案

```python
import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score

def evaluate_regression(y_true, y_pred):
    """
    评估回归模型
    返回所有评估指标
    """
    mse = mean_squared_error(y_true, y_pred)
    rmse = np.sqrt(mse)
    mae = mean_absolute_error(y_true, y_pred)
    r2 = r2_score(y_true, y_pred)
    
    return {
        'MSE': mse,
        'RMSE': rmse,
        'MAE': mae,
        'R²': r2
    }

def plot_residuals(y_true, y_pred):
    """绘制残差分析图"""
    residuals = y_true - y_pred
    
    fig, axes = plt.subplots(1, 2, figsize=(14, 5))
    
    # 残差分布
    axes[0].hist(residuals, bins=30, alpha=0.7, edgecolor='black')
    axes[0].axvline(x=0, color='r', linestyle='--', linewidth=2)
    axes[0].set_xlabel('残差')
    axes[0].set_ylabel('频数')
    axes[0].set_title('残差分布')
    
    # 残差 vs 预测值
    axes[1].scatter(y_pred, residuals, alpha=0.6)
    axes[1].axhline(y=0, color='r', linestyle='--', linewidth=2)
    axes[1].set_xlabel('预测值')
    axes[1].set_ylabel('残差')
    axes[1].set_title('残差 vs 预测值')
    
    plt.tight_layout()
    plt.show()
```

---

## 总评分标准

- **≥80分**：优秀，完全掌握模型评估与优化
- **60-79分**：良好，基本掌握，需要加强实践
- **<60分**：需要重新学习相关知识点

---

## 提交要求

1. 所有代码必须能够直接运行
2. 包含必要的注释和文档字符串
3. 提交代码文件和使用示例
4. 如有可视化，提交生成的图表

