# 练习1：从零实现评估指标

## 练习目标

通过从零实现常用的分类和回归评估指标，深入理解评估指标的计算原理。

## 练习要求

### 任务1：实现分类评估指标

实现以下函数（不能使用scikit-learn的评估函数）：

1. **准确率（Accuracy）**
   ```python
   def accuracy(y_true, y_pred):
       """
       计算分类准确率
       参数:
           y_true: 真实标签，形状为(n,)
           y_pred: 预测标签，形状为(n,)
       返回:
           float: 准确率值
       """
       pass
   ```

2. **精确率（Precision）**
   ```python
   def precision(y_true, y_pred, pos_label=1):
       """
       计算精确率（针对正类）
       参数:
           y_true: 真实标签
           y_pred: 预测标签
           pos_label: 正类标签，默认为1
       返回:
           float: 精确率值
       """
       pass
   ```

3. **召回率（Recall）**
   ```python
   def recall(y_true, y_pred, pos_label=1):
       """
       计算召回率（针对正类）
       参数:
           y_true: 真实标签
           y_pred: 预测标签
           pos_label: 正类标签，默认为1
       返回:
           float: 召回率值
       """
       pass
   ```

4. **F1分数（F1-Score）**
   ```python
   def f1_score(y_true, y_pred, pos_label=1):
       """
       计算F1分数
       参数:
           y_true: 真实标签
           y_pred: 预测标签
           pos_label: 正类标签，默认为1
       返回:
           float: F1分数值
       """
       pass
   ```

5. **混淆矩阵（Confusion Matrix）**
   ```python
   def confusion_matrix(y_true, y_pred, labels=None):
       """
       计算混淆矩阵
       参数:
           y_true: 真实标签
           y_pred: 预测标签
           labels: 标签列表，如果为None则自动推断
       返回:
           numpy.ndarray: 混淆矩阵
       """
       pass
   ```

### 任务2：实现回归评估指标

1. **均方误差（MSE）**
   ```python
   def mean_squared_error(y_true, y_pred):
       """
       计算均方误差
       参数:
           y_true: 真实值，形状为(n,)
           y_pred: 预测值，形状为(n,)
       返回:
           float: MSE值
       """
       pass
   ```

2. **平均绝对误差（MAE）**
   ```python
   def mean_absolute_error(y_true, y_pred):
       """
       计算平均绝对误差
       参数:
           y_true: 真实值
           y_pred: 预测值
       返回:
           float: MAE值
       """
       pass
   ```

3. **R²分数（R-squared）**
   ```python
   def r2_score(y_true, y_pred):
       """
       计算R²分数
       参数:
           y_true: 真实值
           y_pred: 预测值
       返回:
           float: R²值
       """
       pass
   ```

## 测试数据

### 分类测试数据
```python
import numpy as np

# 二分类数据
y_true_binary = np.array([1, 0, 1, 1, 0, 0, 1, 0, 1, 1])
y_pred_binary = np.array([1, 0, 1, 0, 0, 1, 1, 0, 1, 1])

# 多分类数据
y_true_multiclass = np.array([0, 1, 2, 0, 1, 2, 0, 1, 2])
y_pred_multiclass = np.array([0, 1, 1, 0, 1, 2, 0, 1, 2])
```

### 回归测试数据
```python
# 回归数据
y_true_reg = np.array([3.0, -0.5, 2.0, 7.0, 4.2])
y_pred_reg = np.array([2.5, 0.0, 2.1, 8.0, 3.8])
```

## 验证方法

使用scikit-learn的评估函数验证你的实现：

```python
from sklearn.metrics import (
    accuracy_score, precision_score, recall_score, f1_score,
    confusion_matrix, mean_squared_error, mean_absolute_error, r2_score
)

# 验证分类指标
assert abs(accuracy(y_true_binary, y_pred_binary) - accuracy_score(y_true_binary, y_pred_binary)) < 1e-6
assert abs(precision(y_true_binary, y_pred_binary) - precision_score(y_true_binary, y_pred_binary)) < 1e-6
# ... 其他验证
```

## 提示

1. **准确率**：正确预测的样本数 / 总样本数
2. **精确率**：TP / (TP + FP)，即预测为正类中真正为正类的比例
3. **召回率**：TP / (TP + FN)，即真正为正类中被正确预测的比例
4. **F1分数**：2 * (精确率 * 召回率) / (精确率 + 召回率)
5. **混淆矩阵**：行表示真实标签，列表示预测标签
6. **MSE**：平均的平方误差
7. **MAE**：平均的绝对误差
8. **R²**：1 - (SS_res / SS_tot)，其中SS_res是残差平方和，SS_tot是总平方和

## 思考题

1. 为什么精确率和召回率是矛盾的？如何平衡它们？
2. 在什么情况下使用F1分数比使用准确率更合适？
3. R²分数为负数意味着什么？
4. 混淆矩阵如何帮助我们理解模型的错误类型？

## 难度等级

**基础** - 需要理解评估指标的定义和计算方法

## 预计时间

2-3小时

