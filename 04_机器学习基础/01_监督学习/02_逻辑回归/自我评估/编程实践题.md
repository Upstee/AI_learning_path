# 逻辑回归 - 编程实践题

## 题目1：实现逻辑回归算法（40分）

### 要求

不使用任何机器学习库（如scikit-learn），从零实现逻辑回归算法。

### 具体任务

1. **实现Sigmoid函数**（5分）
   - 函数签名：`def sigmoid(z)`
   - 处理数值溢出问题
   - 返回Sigmoid函数值

2. **实现损失函数**（10分）
   - 函数签名：`def compute_cost(X, y, theta)`
   - 计算交叉熵损失
   - 公式：$J(\theta) = -\frac{1}{m}\sum_{i=1}^{m} [y^{(i)} \log h_\theta(x^{(i)}) + (1-y^{(i)}) \log(1 - h_\theta(x^{(i)}))]$

3. **实现梯度计算**（10分）
   - 函数签名：`def compute_gradient(X, y, theta)`
   - 计算梯度向量
   - 公式：$\frac{\partial J}{\partial \theta_j} = \frac{1}{m}\sum_{i=1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) x_j^{(i)}$

4. **实现梯度下降**（10分）
   - 函数签名：`def gradient_descent(X, y, theta, learning_rate, iterations)`
   - 使用梯度下降优化参数
   - 记录每次迭代的损失值

5. **实现预测函数**（5分）
   - 函数签名：`def predict(X, theta, threshold=0.5)`
   - 返回预测类别（0或1）

### 测试要求

使用以下代码测试你的实现：

```python
import numpy as np
from sklearn.datasets import make_classification
from sklearn.model_selection import train_test_split

# 生成数据
X, y = make_classification(n_samples=1000, n_features=2, n_redundant=0, 
                           random_state=42)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# 添加偏置项
X_train = np.hstack([np.ones((X_train.shape[0], 1)), X_train])
X_test = np.hstack([np.ones((X_test.shape[0], 1)), X_test])

# 初始化参数
theta = np.zeros(X_train.shape[1])

# 训练模型
theta = gradient_descent(X_train, y_train, theta, learning_rate=0.1, iterations=1000)

# 预测
y_pred = predict(X_test, theta)

# 计算准确率
accuracy = np.mean(y_pred == y_test)
print(f"准确率: {accuracy:.4f}")
```

### 评分标准

- **正确性**（30分）：算法实现正确，能正确分类
- **代码质量**（10分）：代码清晰，有注释，结构合理

### 提交要求

- 代码文件：`编程题1_答案.py`
- 包含所有函数实现
- 包含测试代码
- 包含运行结果

---

## 题目2：使用scikit-learn进行逻辑回归（30分）

### 要求

使用scikit-learn实现逻辑回归，并进行完整的模型评估。

### 具体任务

1. **数据准备**（5分）
   - 加载数据集（如乳腺癌数据集）
   - 数据预处理（标准化）
   - 划分训练集和测试集

2. **模型训练**（5分）
   - 使用LogisticRegression训练模型
   - 尝试不同的正则化参数C

3. **模型评估**（15分）
   - 计算准确率、精确率、召回率、F1分数
   - 绘制ROC曲线和计算AUC
   - 绘制混淆矩阵
   - 分析特征重要性

4. **结果可视化**（5分）
   - 可视化ROC曲线
   - 可视化混淆矩阵
   - 可视化特征重要性

### 评分标准

- **正确性**（20分）：正确使用scikit-learn API
- **完整性**（5分）：包含所有要求的评估指标
- **可视化**（5分）：图表清晰美观

### 提交要求

- 代码文件：`编程题2_答案.py`
- 包含完整的代码和可视化
- 包含结果分析

---

## 题目3：处理类别不平衡问题（30分）

### 要求

使用逻辑回归处理类别不平衡问题，比较不同方法的效果。

### 具体任务

1. **问题识别**（5分）
   - 加载不平衡数据集
   - 分析类别分布
   - 评估不平衡对模型的影响

2. **方法1：过采样（SMOTE）**（8分）
   - 使用SMOTE生成少数类样本
   - 训练模型
   - 评估性能

3. **方法2：类别权重**（8分）
   - 使用`class_weight='balanced'`
   - 训练模型
   - 评估性能

4. **方法3：阈值调整**（9分）
   - 使用ROC曲线选择最优阈值
   - 调整决策阈值
   - 评估不同阈值的效果

### 对比分析

- 比较不同方法的准确率、精确率、召回率、F1分数
- 绘制ROC曲线对比
- 分析各方法的优缺点

### 评分标准

- **正确性**（20分）：正确实现所有方法
- **对比分析**（10分）：深入分析不同方法的效果

### 提交要求

- 代码文件：`编程题3_答案.py`
- 包含所有方法的实现
- 包含详细的对比分析

---

## 总体要求

1. **代码质量**
   - 代码清晰，有注释
   - 函数模块化
   - 错误处理

2. **文档**
   - 每个函数有文档字符串
   - 关键步骤有注释
   - 结果有说明

3. **可运行性**
   - 所有代码可以直接运行
   - 不依赖外部数据文件（除非明确要求）
   - 输出结果清晰

---

## 评分汇总

- **题目1**：40分
- **题目2**：30分
- **题目3**：30分
- **总分**：100分
- **及格线**：80分

---

**完成后，请将所有答案文件放在 `答案/` 文件夹中。**

