# 逻辑回归 - 编程题答案说明

## 题目1：实现逻辑回归算法

### 关键实现点

1. **Sigmoid函数**
   ```python
   def sigmoid(z):
       # 防止溢出
       z = np.clip(z, -500, 500)
       return 1 / (1 + np.exp(-z))
   ```

2. **损失函数**
   ```python
   def compute_cost(X, y, theta):
       m = X.shape[0]
       h = sigmoid(X @ theta)
       # 避免log(0)
       cost = -(1/m) * np.sum(y * np.log(h + 1e-15) + 
                              (1-y) * np.log(1-h + 1e-15))
       return cost
   ```

3. **梯度计算**
   ```python
   def compute_gradient(X, y, theta):
       m = X.shape[0]
       h = sigmoid(X @ theta)
       gradient = (1/m) * X.T @ (h - y)
       return gradient
   ```

4. **梯度下降**
   ```python
   def gradient_descent(X, y, theta, learning_rate, iterations):
       cost_history = []
       for i in range(iterations):
           gradient = compute_gradient(X, y, theta)
           theta -= learning_rate * gradient
           cost = compute_cost(X, y, theta)
           cost_history.append(cost)
       return theta, cost_history
   ```

### 评分要点

- 正确实现所有函数
- 处理数值稳定性问题
- 代码清晰，有注释
- 测试结果正确（准确率 > 0.85）

---

## 题目2：使用scikit-learn进行逻辑回归

### 关键实现点

1. **数据准备**
   ```python
   from sklearn.datasets import load_breast_cancer
   from sklearn.preprocessing import StandardScaler
   from sklearn.model_selection import train_test_split
   
   data = load_breast_cancer()
   X, y = data.data, data.target
   X_train, X_test, y_train, y_test = train_test_split(
       X, y, test_size=0.2, random_state=42
   )
   scaler = StandardScaler()
   X_train_scaled = scaler.fit_transform(X_train)
   X_test_scaled = scaler.transform(X_test)
   ```

2. **模型训练和评估**
   ```python
   from sklearn.linear_model import LogisticRegression
   from sklearn.metrics import (accuracy_score, classification_report,
                               confusion_matrix, roc_curve, auc)
   
   model = LogisticRegression(random_state=42, max_iter=1000)
   model.fit(X_train_scaled, y_train)
   y_pred = model.predict(X_test_scaled)
   y_proba = model.predict_proba(X_test_scaled)[:, 1]
   ```

3. **可视化**
   - ROC曲线
   - 混淆矩阵热力图
   - 特征重要性条形图

### 评分要点

- 正确使用scikit-learn API
- 包含所有要求的评估指标
- 可视化清晰美观
- 结果分析深入

---

## 题目3：处理类别不平衡问题

### 关键实现点

1. **SMOTE过采样**
   ```python
   from imblearn.over_sampling import SMOTE
   
   smote = SMOTE(random_state=42)
   X_resampled, y_resampled = smote.fit_resample(X_train, y_train)
   ```

2. **类别权重**
   ```python
   model = LogisticRegression(class_weight='balanced', random_state=42)
   model.fit(X_train, y_train)
   ```

3. **阈值调整**
   ```python
   from sklearn.metrics import roc_curve
   
   fpr, tpr, thresholds = roc_curve(y_test, y_proba)
   optimal_idx = np.argmax(tpr - fpr)
   optimal_threshold = thresholds[optimal_idx]
   y_pred_optimal = (y_proba >= optimal_threshold).astype(int)
   ```

### 评分要点

- 正确实现所有方法
- 深入对比分析
- 可视化对比结果
- 提出选择建议

---

## 通用评分标准

### 代码质量（20分）
- 代码清晰，有注释
- 函数模块化
- 错误处理
- 可读性强

### 正确性（60分）
- 算法实现正确
- 结果正确
- 测试通过

### 完整性（20分）
- 包含所有要求的功能
- 有测试代码
- 有结果说明

---

**注意**：这些是参考答案的说明，实际答案应该由学生完成。教师可以根据这些要点进行评分。

